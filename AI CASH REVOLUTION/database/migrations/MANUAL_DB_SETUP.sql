-- ========================================
-- MANUAL DATABASE SETUP
-- Esegui questo SQL nel Supabase SQL Editor
-- Dashboard > SQL Editor > New Query
-- ========================================

-- Table: collective_signals
-- Stores every signal generated by all users
CREATE TABLE IF NOT EXISTS collective_signals (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,

  -- Signal Details
  symbol VARCHAR(20) NOT NULL,
  signal_type VARCHAR(10) NOT NULL CHECK (signal_type IN ('BUY', 'SELL', 'HOLD')),
  confidence DECIMAL(5,2) NOT NULL,

  -- Entry Details
  entry_price DECIMAL(20,8) NOT NULL,
  entry_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  -- Exit Levels
  stop_loss DECIMAL(20,8) NOT NULL,
  take_profit DECIMAL(20,8) NOT NULL,
  risk_reward DECIMAL(10,2),

  -- Market Context (for ML features)
  session VARCHAR(20) NOT NULL CHECK (session IN ('ASIAN', 'LONDON', 'NY', 'OVERLAP')),
  timeframe VARCHAR(10) NOT NULL,
  regime VARCHAR(20) CHECK (regime IN ('RANGE', 'TREND_BULLISH', 'TREND_BEARISH')),

  -- Technical Context (features for ML)
  ema9 DECIMAL(20,8),
  ema21 DECIMAL(20,8),
  ema50 DECIMAL(20,8),
  ema200 DECIMAL(20,8),
  rsi DECIMAL(5,2),
  bollinger_width DECIMAL(10,4),
  bollinger_percentb DECIMAL(5,4),

  -- Multi-timeframe alignment
  m15_trend VARCHAR(10) CHECK (m15_trend IN ('BULLISH', 'BEARISH', 'NEUTRAL')),
  m5_trend VARCHAR(10) CHECK (m5_trend IN ('BULLISH', 'BEARISH', 'NEUTRAL')),
  h1_trend VARCHAR(10) CHECK (h1_trend IN ('BULLISH', 'BEARISH', 'NEUTRAL')),

  -- Pattern detected
  pattern_m15 VARCHAR(50),
  pattern_m5 VARCHAR(50),

  -- Confluence flags (for feature importance)
  has_volume_confirm BOOLEAN DEFAULT false,
  has_session_align BOOLEAN DEFAULT false,
  has_pullback_entry BOOLEAN DEFAULT false,
  has_strong_momentum BOOLEAN DEFAULT false,
  has_key_level BOOLEAN DEFAULT false,
  has_h1_confirm BOOLEAN DEFAULT false,
  has_pattern_confirm BOOLEAN DEFAULT false,
  has_ema_align BOOLEAN DEFAULT false,
  has_bb_signal BOOLEAN DEFAULT false,
  has_regime_align BOOLEAN DEFAULT false,

  -- Outcome (updated tick by tick)
  status VARCHAR(20) DEFAULT 'OPEN' CHECK (status IN ('OPEN', 'TP_HIT', 'SL_HIT', 'MANUAL_CLOSE', 'EXPIRED')),
  exit_price DECIMAL(20,8),
  exit_time TIMESTAMPTZ,
  pnl DECIMAL(20,8),
  pnl_percent DECIMAL(10,4),
  duration_minutes INTEGER,

  -- Tick tracking
  highest_price DECIMAL(20,8),
  lowest_price DECIMAL(20,8),
  max_favorable_excursion DECIMAL(10,4),
  max_adverse_excursion DECIMAL(10,4),

  -- Metadata
  signal_version VARCHAR(20),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for fast queries
CREATE INDEX IF NOT EXISTS idx_collective_signals_symbol ON collective_signals(symbol);
CREATE INDEX IF NOT EXISTS idx_collective_signals_status ON collective_signals(status);
CREATE INDEX IF NOT EXISTS idx_collective_signals_session ON collective_signals(session);
CREATE INDEX IF NOT EXISTS idx_collective_signals_regime ON collective_signals(regime);
CREATE INDEX IF NOT EXISTS idx_collective_signals_entry_time ON collective_signals(entry_time DESC);
CREATE INDEX IF NOT EXISTS idx_collective_signals_user ON collective_signals(user_id);
CREATE INDEX IF NOT EXISTS idx_collective_signals_outcome ON collective_signals(status, pnl);

-- Composite indexes for ML queries
CREATE INDEX IF NOT EXISTS idx_ml_features ON collective_signals(symbol, session, regime, status);
CREATE INDEX IF NOT EXISTS idx_ml_patterns ON collective_signals(pattern_m15, pattern_m5, status);

-- Table: ml_weight_optimization
-- Stores optimized confluence weights (updated by ML)
CREATE TABLE IF NOT EXISTS ml_weight_optimization (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Context
  symbol VARCHAR(20),
  session VARCHAR(20),
  regime VARCHAR(20),

  -- Optimized Weights (starts with defaults)
  weight_volume DECIMAL(5,2) DEFAULT 5.0,
  weight_session DECIMAL(5,2) DEFAULT 8.0,
  weight_pullback DECIMAL(5,2) DEFAULT 12.0,
  weight_momentum DECIMAL(5,2) DEFAULT 10.0,
  weight_key_level DECIMAL(5,2) DEFAULT 8.0,
  weight_h1_confirm DECIMAL(5,2) DEFAULT 5.0,
  weight_ema_align DECIMAL(5,2) DEFAULT 25.0,
  weight_bb_signal DECIMAL(5,2) DEFAULT 18.0,
  weight_regime_align DECIMAL(5,2) DEFAULT 12.0,
  weight_pattern DECIMAL(5,2) DEFAULT 15.0,

  -- Performance Metrics
  total_signals INTEGER DEFAULT 0,
  winning_signals INTEGER DEFAULT 0,
  win_rate DECIMAL(5,2) DEFAULT 0.0,
  avg_pnl DECIMAL(10,4) DEFAULT 0.0,
  sharpe_ratio DECIMAL(10,4),

  -- ML Training Info
  last_training TIMESTAMPTZ DEFAULT NOW(),
  training_samples INTEGER DEFAULT 0,
  model_version VARCHAR(20),

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),

  -- Unique constraint per context
  UNIQUE(symbol, session, regime)
);

-- Default weights for all contexts
INSERT INTO ml_weight_optimization (symbol, session, regime) VALUES
  ('XAUUSD', 'ASIAN', 'RANGE'),
  ('XAUUSD', 'ASIAN', 'TREND_BULLISH'),
  ('XAUUSD', 'ASIAN', 'TREND_BEARISH'),
  ('XAUUSD', 'LONDON', 'RANGE'),
  ('XAUUSD', 'LONDON', 'TREND_BULLISH'),
  ('XAUUSD', 'LONDON', 'TREND_BEARISH'),
  ('XAUUSD', 'NY', 'RANGE'),
  ('XAUUSD', 'NY', 'TREND_BULLISH'),
  ('XAUUSD', 'NY', 'TREND_BEARISH'),
  ('XAUUSD', 'OVERLAP', 'RANGE'),
  ('XAUUSD', 'OVERLAP', 'TREND_BULLISH'),
  ('XAUUSD', 'OVERLAP', 'TREND_BEARISH'),
  ('EURUSD', 'ASIAN', 'RANGE'),
  ('EURUSD', 'LONDON', 'TREND_BULLISH'),
  ('EURUSD', 'NY', 'TREND_BULLISH')
ON CONFLICT DO NOTHING;

-- Table: ml_training_log
-- Logs every ML training run
CREATE TABLE IF NOT EXISTS ml_training_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  training_type VARCHAR(50) NOT NULL,
  context_filter JSONB,

  -- Training Results
  samples_used INTEGER NOT NULL,
  features_used TEXT[],
  algorithm VARCHAR(50),

  -- Performance Before/After
  win_rate_before DECIMAL(5,2),
  win_rate_after DECIMAL(5,2),
  sharpe_before DECIMAL(10,4),
  sharpe_after DECIMAL(10,4),

  -- Weight Changes
  weight_changes JSONB,

  -- Metadata
  duration_seconds INTEGER,
  trained_at TIMESTAMPTZ DEFAULT NOW()
);

-- Function: Update signal tick by tick
CREATE OR REPLACE FUNCTION update_signal_tick(
  p_signal_id UUID,
  p_current_price DECIMAL(20,8)
)
RETURNS VOID AS $BODY$
DECLARE
  v_signal collective_signals%ROWTYPE;
  v_pnl DECIMAL(20,8);
  v_pnl_percent DECIMAL(10,4);
  v_mfe DECIMAL(10,4);
  v_mae DECIMAL(10,4);
BEGIN
  -- Get signal
  SELECT * INTO v_signal FROM collective_signals WHERE id = p_signal_id AND status = 'OPEN';

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Update highest/lowest
  UPDATE collective_signals
  SET
    highest_price = GREATEST(COALESCE(highest_price, p_current_price), p_current_price),
    lowest_price = LEAST(COALESCE(lowest_price, p_current_price), p_current_price),
    updated_at = NOW()
  WHERE id = p_signal_id;

  -- Calculate MFE/MAE
  IF v_signal.signal_type = 'BUY' THEN
    v_mfe := ((GREATEST(COALESCE(v_signal.highest_price, p_current_price), p_current_price) - v_signal.entry_price) / v_signal.entry_price) * 100;
    v_mae := ((v_signal.entry_price - LEAST(COALESCE(v_signal.lowest_price, p_current_price), p_current_price)) / v_signal.entry_price) * 100;

    -- Check TP hit
    IF p_current_price >= v_signal.take_profit THEN
      v_pnl := v_signal.take_profit - v_signal.entry_price;
      v_pnl_percent := (v_pnl / v_signal.entry_price) * 100;

      UPDATE collective_signals
      SET
        status = 'TP_HIT',
        exit_price = v_signal.take_profit,
        exit_time = NOW(),
        pnl = v_pnl,
        pnl_percent = v_pnl_percent,
        duration_minutes = EXTRACT(EPOCH FROM (NOW() - entry_time)) / 60,
        max_favorable_excursion = v_mfe,
        max_adverse_excursion = v_mae,
        updated_at = NOW()
      WHERE id = p_signal_id;
    -- Check SL hit
    ELSIF p_current_price <= v_signal.stop_loss THEN
      v_pnl := v_signal.stop_loss - v_signal.entry_price;
      v_pnl_percent := (v_pnl / v_signal.entry_price) * 100;

      UPDATE collective_signals
      SET
        status = 'SL_HIT',
        exit_price = v_signal.stop_loss,
        exit_time = NOW(),
        pnl = v_pnl,
        pnl_percent = v_pnl_percent,
        duration_minutes = EXTRACT(EPOCH FROM (NOW() - entry_time)) / 60,
        max_favorable_excursion = v_mfe,
        max_adverse_excursion = v_mae,
        updated_at = NOW()
      WHERE id = p_signal_id;
    ELSE
      -- Just update MFE/MAE
      UPDATE collective_signals
      SET
        max_favorable_excursion = v_mfe,
        max_adverse_excursion = v_mae,
        updated_at = NOW()
      WHERE id = p_signal_id;
    END IF;
  ELSE -- SELL
    v_mfe := ((v_signal.entry_price - LEAST(COALESCE(v_signal.lowest_price, p_current_price), p_current_price)) / v_signal.entry_price) * 100;
    v_mae := ((GREATEST(COALESCE(v_signal.highest_price, p_current_price), p_current_price) - v_signal.entry_price) / v_signal.entry_price) * 100;

    -- Check TP hit
    IF p_current_price <= v_signal.take_profit THEN
      v_pnl := v_signal.entry_price - v_signal.take_profit;
      v_pnl_percent := (v_pnl / v_signal.entry_price) * 100;

      UPDATE collective_signals
      SET
        status = 'TP_HIT',
        exit_price = v_signal.take_profit,
        exit_time = NOW(),
        pnl = v_pnl,
        pnl_percent = v_pnl_percent,
        duration_minutes = EXTRACT(EPOCH FROM (NOW() - entry_time)) / 60,
        max_favorable_excursion = v_mfe,
        max_adverse_excursion = v_mae,
        updated_at = NOW()
      WHERE id = p_signal_id;
    -- Check SL hit
    ELSIF p_current_price >= v_signal.stop_loss THEN
      v_pnl := v_signal.entry_price - v_signal.stop_loss;
      v_pnl_percent := (v_pnl / v_signal.entry_price) * 100;

      UPDATE collective_signals
      SET
        status = 'SL_HIT',
        exit_price = v_signal.stop_loss,
        exit_time = NOW(),
        pnl = v_pnl,
        pnl_percent = v_pnl_percent,
        duration_minutes = EXTRACT(EPOCH FROM (NOW() - entry_time)) / 60,
        max_favorable_excursion = v_mfe,
        max_adverse_excursion = v_mae,
        updated_at = NOW()
      WHERE id = p_signal_id;
    ELSE
      -- Just update MFE/MAE
      UPDATE collective_signals
      SET
        max_favorable_excursion = v_mfe,
        max_adverse_excursion = v_mae,
        updated_at = NOW()
      WHERE id = p_signal_id;
    END IF;
  END IF;
END;
$BODY$ LANGUAGE plpgsql;

-- Enable RLS
ALTER TABLE collective_signals ENABLE ROW LEVEL SECURITY;
ALTER TABLE ml_weight_optimization ENABLE ROW LEVEL SECURITY;
ALTER TABLE ml_training_log ENABLE ROW LEVEL SECURITY;

-- Policies: Users can read all signals, write their own
CREATE POLICY IF NOT EXISTS "Users can read all signals"
  ON collective_signals FOR SELECT
  USING (true);

CREATE POLICY IF NOT EXISTS "Users can insert their signals"
  ON collective_signals FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY IF NOT EXISTS "Service role full access"
  ON collective_signals FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- ML weights readable by all
CREATE POLICY IF NOT EXISTS "Everyone can read ML weights"
  ON ml_weight_optimization FOR SELECT
  USING (true);

CREATE POLICY IF NOT EXISTS "Service role can update weights"
  ON ml_weight_optimization FOR ALL
  USING (auth.jwt()->>'role' = 'service_role');

-- Training log readable by all
CREATE POLICY IF NOT EXISTS "Everyone can read training log"
  ON ml_training_log FOR SELECT
  USING (true);

CREATE POLICY IF NOT EXISTS "Service role can log training"
  ON ml_training_log FOR INSERT
  WITH CHECK (auth.jwt()->>'role' = 'service_role');

-- Success message
DO $$
BEGIN
  RAISE NOTICE '‚úÖ ML Collective Learning database setup completed successfully!';
  RAISE NOTICE 'üìä Tables created: collective_signals, ml_weight_optimization, ml_training_log';
  RAISE NOTICE 'üîß Function created: update_signal_tick()';
  RAISE NOTICE 'üîê RLS policies enabled';
END $$;
